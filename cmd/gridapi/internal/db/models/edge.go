package models

import (
	"errors"
	"regexp"
	"time"

	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

// EdgeStatus represents the current status of a dependency edge.
// Edge status uses a composite model with two orthogonal dimensions:
// 1. Drift: clean (in_digest == out_digest) vs dirty (in_digest != out_digest)
// 2. Validation: valid (passes schema) vs invalid (fails schema)
type EdgeStatus string

const (
	EdgeStatusPending          EdgeStatus = "pending"           // Initial state, no observation yet
	EdgeStatusClean            EdgeStatus = "clean"             // in_digest == out_digest AND output passes schema validation
	EdgeStatusCleanInvalid     EdgeStatus = "clean-invalid"     // in_digest == out_digest AND output fails schema validation
	EdgeStatusDirty            EdgeStatus = "dirty"             // in_digest != out_digest AND output passes schema validation
	EdgeStatusDirtyInvalid     EdgeStatus = "dirty-invalid"     // in_digest != out_digest AND output fails schema validation
	EdgeStatusPotentiallyStale EdgeStatus = "potentially-stale" // Transitive upstream dirty
	EdgeStatusMock             EdgeStatus = "mock"              // Using mock value, real output not yet exists
	EdgeStatusMissingOutput    EdgeStatus = "missing-output"    // Producer output key removed
)

// Edge represents a directed dependency edge from producer output to consumer state
type Edge struct {
	bun.BaseModel `bun:"table:edges,alias:e"`

	ID          int64      `bun:"id,pk,autoincrement"`
	FromState   string     `bun:"from_state,notnull,type:uuid"`
	FromOutput  string     `bun:"from_output,notnull"`
	ToState     string     `bun:"to_state,notnull,type:uuid"`
	ToInputName string     `bun:"to_input_name,notnull"` // Always non-null (generated by service if not provided)
	Status      EdgeStatus `bun:"status,notnull,default:'pending'"`
	InDigest    string     `bun:"in_digest"`             // Producer output fingerprint
	OutDigest   string     `bun:"out_digest"`            // Consumer observed fingerprint
	MockValue   []byte     `bun:"mock_value,type:jsonb"` // Optional mock for ahead-of-time deps
	LastInAt    *time.Time `bun:"last_in_at"`
	LastOutAt   *time.Time `bun:"last_out_at"`
	CreatedAt   time.Time  `bun:"created_at,notnull,default:current_timestamp"`
	UpdatedAt   time.Time  `bun:"updated_at,notnull,default:current_timestamp"`

	// Relationships for eager loading (populated only when using Relation())
	FromStateRel   *State        `bun:"rel:belongs-to,join:from_state=guid"`
	ToStateRel     *State        `bun:"rel:belongs-to,join:to_state=guid"`
	ProducerOutput *StateOutput  `bun:"rel:belongs-to,join:from_state=state_guid,join:from_output=output_key"`
}

var slugRegex = regexp.MustCompile(`^[a-z0-9_-]+$`)

// ValidateForCreate verifies the edge is well formed before insertion.
func (e *Edge) ValidateForCreate() error {
	// UUIDs
	if _, err := uuid.Parse(e.FromState); err != nil {
		return errors.New("from_state must be valid UUID")
	}
	if _, err := uuid.Parse(e.ToState); err != nil {
		return errors.New("to_state must be valid UUID")
	}

	// No self-loops
	if e.FromState == e.ToState {
		return errors.New("self-loops not allowed")
	}

	// from_output required
	if e.FromOutput == "" {
		return errors.New("from_output is required")
	}

	// to_input_name validation (always non-null after service layer processing)
	if e.ToInputName == "" {
		return errors.New("to_input_name is required (should be set by service layer)")
	}
	if !isValidSlug(e.ToInputName) {
		return errors.New("to_input_name must be valid slug: lowercase [a-z0-9_-]")
	}

	// Mock value only valid with mock status
	if e.MockValue != nil && e.Status != EdgeStatusMock {
		return errors.New("mock_value only allowed with status=mock")
	}

	return nil
}

// isValidSlug checks if a string is a valid slug format
func isValidSlug(s string) bool {
	return slugRegex.MatchString(s)
}
