package sdk

import (
	"context"
	"fmt"
	"strings"
	"time"

	"connectrpc.com/connect"
	statev1 "github.com/terraconstructs/grid/api/state/v1"
)

// AddDependency creates a new dependency edge from a producer state's output to a consumer state's input.
// The state references may be specified by logic ID or GUID.
// If ToInputName is empty, it will be auto-generated by the server.
func (c *Client) AddDependency(ctx context.Context, input AddDependencyInput) (*AddDependencyResult, error) {
	if input.FromOutput == "" {
		return nil, fmt.Errorf("from output is required")
	}
	req := &statev1.AddDependencyRequest{FromOutput: input.FromOutput}
	switch {
	case input.From.GUID != "" && input.From.LogicID != "":
		req.FromState = &statev1.AddDependencyRequest_FromGuid{FromGuid: input.From.GUID}
	case input.From.GUID != "":
		req.FromState = &statev1.AddDependencyRequest_FromGuid{FromGuid: input.From.GUID}
	case input.From.LogicID != "":
		req.FromState = &statev1.AddDependencyRequest_FromLogicId{FromLogicId: input.From.LogicID}
	default:
		return nil, fmt.Errorf("from state reference requires guid or logic ID")
	}

	switch {
	case input.To.GUID != "" && input.To.LogicID != "":
		req.ToState = &statev1.AddDependencyRequest_ToGuid{ToGuid: input.To.GUID}
	case input.To.GUID != "":
		req.ToState = &statev1.AddDependencyRequest_ToGuid{ToGuid: input.To.GUID}
	case input.To.LogicID != "":
		req.ToState = &statev1.AddDependencyRequest_ToLogicId{ToLogicId: input.To.LogicID}
	default:
		return nil, fmt.Errorf("to state reference requires guid or logic ID")
	}
	if input.ToInputName != "" {
		req.ToInputName = &input.ToInputName
	}
	if input.MockValueJSON != "" {
		req.MockValueJson = &input.MockValueJSON
	}

	resp, err := c.rpc.AddDependency(ctx, connect.NewRequest(req))
	if err != nil {
		return nil, err
	}

	edge := dependencyEdgeFromProto(resp.Msg.GetEdge())
	return &AddDependencyResult{Edge: edge, AlreadyExists: resp.Msg.GetAlreadyExists()}, nil
}

// RemoveDependency deletes an existing dependency edge by its edge ID.
func (c *Client) RemoveDependency(ctx context.Context, edgeID int64) error {
	if edgeID <= 0 {
		return fmt.Errorf("edge ID must be positive")
	}
	req := connect.NewRequest(&statev1.RemoveDependencyRequest{EdgeId: edgeID})
	_, err := c.rpc.RemoveDependency(ctx, req)
	return err
}

// ListDependencies returns all incoming dependency edges for a consumer state reference.
func (c *Client) ListDependencies(ctx context.Context, ref StateReference) ([]DependencyEdge, error) {
	req, err := newListDependenciesRequest(ref)
	if err != nil {
		return nil, err
	}

	resp, err := c.rpc.ListDependencies(ctx, connect.NewRequest(req))
	if err != nil {
		return nil, err
	}

	return edgesFromProto(resp.Msg.GetEdges()), nil
}

// ListDependents returns all outgoing dependency edges for a producer state reference.
func (c *Client) ListDependents(ctx context.Context, ref StateReference) ([]DependencyEdge, error) {
	req, err := newListDependentsRequest(ref)
	if err != nil {
		return nil, err
	}

	resp, err := c.rpc.ListDependents(ctx, connect.NewRequest(req))
	if err != nil {
		return nil, err
	}

	return edgesFromProto(resp.Msg.GetEdges()), nil
}

// ListAllEdges returns all dependency edges in the system, ordered by ID.
// Used by dashboards and monitoring tools to visualize complete topology.
func (c *Client) ListAllEdges(ctx context.Context) ([]DependencyEdge, error) {
	resp, err := c.rpc.ListAllEdges(ctx, connect.NewRequest(&statev1.ListAllEdgesRequest{}))
	if err != nil {
		return nil, err
	}

	return edgesFromProto(resp.Msg.GetEdges()), nil
}

// SearchByOutput finds every dependency edge that consumes a specific producer output key.
func (c *Client) SearchByOutput(ctx context.Context, outputKey string) ([]DependencyEdge, error) {
	if outputKey == "" {
		return nil, fmt.Errorf("output key is required")
	}
	req := connect.NewRequest(&statev1.SearchByOutputRequest{OutputKey: outputKey})
	resp, err := c.rpc.SearchByOutput(ctx, req)
	if err != nil {
		return nil, err
	}
	return edgesFromProto(resp.Msg.GetEdges()), nil
}

// GetTopologicalOrder returns a layered ordering of states rooted at the provided reference.
func (c *Client) GetTopologicalOrder(ctx context.Context, input TopologyInput) ([]TopologyLayer, error) {
	req, err := newTopologyRequest(input)
	if err != nil {
		return nil, err
	}

	resp, err := c.rpc.GetTopologicalOrder(ctx, connect.NewRequest(req))
	if err != nil {
		return nil, err
	}

	layers := make([]TopologyLayer, 0, len(resp.Msg.GetLayers()))
	for _, layer := range resp.Msg.GetLayers() {
		states := make([]StateReference, 0, len(layer.GetStates()))
		for _, ref := range layer.GetStates() {
			states = append(states, StateReference{
				GUID:    ref.GetGuid(),
				LogicID: ref.GetLogicId(),
			})
		}
		layers = append(layers, TopologyLayer{Level: int(layer.GetLevel()), States: states})
	}
	return layers, nil
}

// GetStateStatus computes the dependency status for the supplied state reference.
func (c *Client) GetStateStatus(ctx context.Context, ref StateReference) (*StateStatus, error) {
	req, err := newStateStatusRequest(ref)
	if err != nil {
		return nil, err
	}

	resp, err := c.rpc.GetStateStatus(ctx, connect.NewRequest(req))
	if err != nil {
		return nil, err
	}

	summaryProto := resp.Msg.GetSummary()
	summary := StatusSummary{}
	if summaryProto != nil {
		summary = StatusSummary{
			IncomingClean:   int(summaryProto.GetIncomingClean()),
			IncomingDirty:   int(summaryProto.GetIncomingDirty()),
			IncomingPending: int(summaryProto.GetIncomingPending()),
			IncomingUnknown: int(summaryProto.GetIncomingUnknown()),
		}
	}

	status := &StateStatus{
		State: StateReference{
			GUID:    resp.Msg.GetGuid(),
			LogicID: resp.Msg.GetLogicId(),
		},
		Status:  resp.Msg.GetStatus(),
		Summary: summary,
	}

	incoming := make([]IncomingEdge, 0, len(resp.Msg.GetIncoming()))
	for _, edge := range resp.Msg.GetIncoming() {
		incoming = append(incoming, incomingEdgeFromProto(edge))
	}
	status.Incoming = incoming

	return status, nil
}

// GetDependencyGraph retrieves the dependency graph for a consumer state reference.
func (c *Client) GetDependencyGraph(ctx context.Context, ref StateReference) (*DependencyGraph, error) {
	req, err := newDependencyGraphRequest(ref)
	if err != nil {
		return nil, err
	}

	resp, err := c.rpc.GetDependencyGraph(ctx, connect.NewRequest(req))
	if err != nil {
		return nil, err
	}

	graph := &DependencyGraph{
		Consumer: StateReference{
			GUID:    resp.Msg.GetConsumerGuid(),
			LogicID: resp.Msg.GetConsumerLogicId(),
		},
		Edges: edgesFromProto(resp.Msg.GetEdges()),
	}

	producers := make([]ProducerState, 0, len(resp.Msg.GetProducers()))
	for _, producer := range resp.Msg.GetProducers() {
		producers = append(producers, ProducerState{
			State: StateReference{
				GUID:    producer.GetGuid(),
				LogicID: producer.GetLogicId(),
			},
			BackendConfig: backendConfigFromProto(producer.BackendConfig),
		})
	}
	graph.Producers = producers

	return graph, nil
}

// --- internal helpers ---------------------------------------------------------------------

func newListDependenciesRequest(ref StateReference) (*statev1.ListDependenciesRequest, error) {
	req := &statev1.ListDependenciesRequest{}
	switch {
	case ref.GUID != "" && ref.LogicID != "":
		req.State = &statev1.ListDependenciesRequest_Guid{Guid: ref.GUID}
	case ref.GUID != "":
		req.State = &statev1.ListDependenciesRequest_Guid{Guid: ref.GUID}
	case ref.LogicID != "":
		req.State = &statev1.ListDependenciesRequest_LogicId{LogicId: ref.LogicID}
	default:
		return nil, fmt.Errorf("state reference requires guid or logic ID")
	}
	return req, nil
}

func newListDependentsRequest(ref StateReference) (*statev1.ListDependentsRequest, error) {
	req := &statev1.ListDependentsRequest{}
	switch {
	case ref.GUID != "" && ref.LogicID != "":
		req.State = &statev1.ListDependentsRequest_Guid{Guid: ref.GUID}
	case ref.GUID != "":
		req.State = &statev1.ListDependentsRequest_Guid{Guid: ref.GUID}
	case ref.LogicID != "":
		req.State = &statev1.ListDependentsRequest_LogicId{LogicId: ref.LogicID}
	default:
		return nil, fmt.Errorf("state reference requires guid or logic ID")
	}
	return req, nil
}

func newStateStatusRequest(ref StateReference) (*statev1.GetStateStatusRequest, error) {
	req := &statev1.GetStateStatusRequest{}
	switch {
	case ref.GUID != "" && ref.LogicID != "":
		req.State = &statev1.GetStateStatusRequest_Guid{Guid: ref.GUID}
	case ref.GUID != "":
		req.State = &statev1.GetStateStatusRequest_Guid{Guid: ref.GUID}
	case ref.LogicID != "":
		req.State = &statev1.GetStateStatusRequest_LogicId{LogicId: ref.LogicID}
	default:
		return nil, fmt.Errorf("state reference requires guid or logic ID")
	}
	return req, nil
}

func newDependencyGraphRequest(ref StateReference) (*statev1.GetDependencyGraphRequest, error) {
	req := &statev1.GetDependencyGraphRequest{}
	switch {
	case ref.GUID != "" && ref.LogicID != "":
		req.State = &statev1.GetDependencyGraphRequest_Guid{Guid: ref.GUID}
	case ref.GUID != "":
		req.State = &statev1.GetDependencyGraphRequest_Guid{Guid: ref.GUID}
	case ref.LogicID != "":
		req.State = &statev1.GetDependencyGraphRequest_LogicId{LogicId: ref.LogicID}
	default:
		return nil, fmt.Errorf("state reference requires guid or logic ID")
	}
	return req, nil
}

func newTopologyRequest(input TopologyInput) (*statev1.GetTopologicalOrderRequest, error) {
	if input.Root.GUID == "" && input.Root.LogicID == "" {
		return nil, fmt.Errorf("topology root must provide guid or logic ID")
	}

	req := &statev1.GetTopologicalOrderRequest{}
	if input.Root.GUID != "" {
		req.State = &statev1.GetTopologicalOrderRequest_Guid{Guid: input.Root.GUID}
	} else {
		req.State = &statev1.GetTopologicalOrderRequest_LogicId{LogicId: input.Root.LogicID}
	}

	dir := strings.ToLower(string(input.Direction))
	switch dir {
	case "", string(Downstream):
		// default downstream; omit field to defer to server default when empty
	case string(Upstream):
		direction := string(Upstream)
		req.Direction = &direction
	default:
		return nil, fmt.Errorf("invalid topology direction %q", dir)
	}

	return req, nil
}

func edgesFromProto(edges []*statev1.DependencyEdge) []DependencyEdge {
	result := make([]DependencyEdge, 0, len(edges))
	for _, edge := range edges {
		result = append(result, dependencyEdgeFromProto(edge))
	}
	return result
}

func dependencyEdgeFromProto(edge *statev1.DependencyEdge) DependencyEdge {
	if edge == nil {
		return DependencyEdge{}
	}

	var lastIn *time.Time
	if edge.LastInAt != nil {
		t := edge.LastInAt.AsTime()
		lastIn = &t
	}

	var lastOut *time.Time
	if edge.LastOutAt != nil {
		t := edge.LastOutAt.AsTime()
		lastOut = &t
	}

	var created time.Time
	if edge.CreatedAt != nil {
		created = edge.CreatedAt.AsTime()
	}
	var updated time.Time
	if edge.UpdatedAt != nil {
		updated = edge.UpdatedAt.AsTime()
	}

	mock := ""
	if edge.MockValueJson != nil {
		mock = edge.GetMockValueJson()
	}

	toInput := ""
	if edge.ToInputName != nil {
		toInput = edge.GetToInputName()
	}

	return DependencyEdge{
		ID:             edge.GetId(),
		From:           StateReference{GUID: edge.GetFromGuid(), LogicID: edge.GetFromLogicId()},
		FromOutput:     edge.GetFromOutput(),
		To:             StateReference{GUID: edge.GetToGuid(), LogicID: edge.GetToLogicId()},
		ToInputName:    toInput,
		Status:         edge.GetStatus(),
		InDigest:       edge.GetInDigest(),
		OutDigest:      edge.GetOutDigest(),
		MockValueJSON:  mock,
		LastProducedAt: lastIn,
		LastConsumedAt: lastOut,
		CreatedAt:      created,
		UpdatedAt:      updated,
	}
}

func incomingEdgeFromProto(edge *statev1.IncomingEdgeView) IncomingEdge {
	if edge == nil {
		return IncomingEdge{}
	}

	var lastIn *time.Time
	if edge.LastInAt != nil {
		t := edge.LastInAt.AsTime()
		lastIn = &t
	}

	var lastOut *time.Time
	if edge.LastOutAt != nil {
		t := edge.LastOutAt.AsTime()
		lastOut = &t
	}

	return IncomingEdge{
		ID: edge.GetEdgeId(),
		From: StateReference{
			GUID:    edge.GetFromGuid(),
			LogicID: edge.GetFromLogicId(),
		},
		FromOutput:     edge.GetFromOutput(),
		Status:         edge.GetStatus(),
		InDigest:       edge.GetInDigest(),
		OutDigest:      edge.GetOutDigest(),
		LastProducedAt: lastIn,
		LastConsumedAt: lastOut,
	}
}
