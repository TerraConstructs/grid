# Research: State Dependency Management

**Feature**: State Dependency Management
**Date**: 2025-10-02
**Status**: Complete

## Research Questions

### 1. RDBMS Patterns for Directed Acyclic Multigraphs (DAGs)

#### Decision: Edge Table (Adjacency List) + Cycle Prevention Trigger

**Schema Design**:

Defined through Bun ORM Model.

```sql
-- Multigraph-friendly edge table with composite uniqueness
CREATE TABLE edges (
  id              BIGSERIAL PRIMARY KEY,
  from_state      UUID NOT NULL REFERENCES states(guid) ON DELETE CASCADE,
  from_output     TEXT NOT NULL,
  to_state        UUID NOT NULL REFERENCES states(guid) ON DELETE CASCADE,
  to_input_name   TEXT NOT NULL,  -- Always non-null (generated by service if not provided)
  status          TEXT NOT NULL DEFAULT 'pending',
  in_digest       TEXT,  -- Fingerprint of producer output when last observed
  out_digest      TEXT,  -- Fingerprint consumer observed (matches in_digest when clean)
  mock_value      JSONB, -- Mock value for edges declared before output exists
  last_in_at      TIMESTAMPTZ,
  last_out_at     TIMESTAMPTZ,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE (from_state, from_output, to_state),
  UNIQUE (to_state, to_input_name)
);

CREATE INDEX idx_edges_from_state ON edges(from_state);
CREATE INDEX idx_edges_to_state ON edges(to_state);
CREATE INDEX idx_edges_status ON edges(status);

-- Cycle prevention trigger using recursive CTE
CREATE OR REPLACE FUNCTION prevent_cycle() RETURNS trigger AS $$
BEGIN
  -- Check if NEW.to_state can already reach NEW.from_state
  IF EXISTS (
    WITH RECURSIVE reachable(node) AS (
      SELECT NEW.to_state
      UNION ALL
      SELECT e.to_state
      FROM edges e
      JOIN reachable r ON e.from_state = r.node
    )
    SELECT 1 FROM reachable WHERE node = NEW.from_state
  ) THEN
    RAISE EXCEPTION 'cycle detected: % -> %', NEW.from_state, NEW.to_state;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER edges_prevent_cycle
BEFORE INSERT OR UPDATE ON edges
FOR EACH ROW EXECUTE FUNCTION prevent_cycle();
```

**Rationale**:
- **Pros**: Simple, flexible, fits DAGs and multigraphs naturally
- **Cons**: Longer paths slower to query than specialized patterns
- **Performance**: Tuned with indexes on `(from_state)`, `(to_state)`, `(status)`
- **Traversal**: Use Bun's CTE support for recursive queries (Bun has first-class `With(...)` support)
- **Cycle Prevention**: DB-level trigger is defensive correctness layer; prevents races under concurrent writes

**Alternatives Considered**:
1. **Closure Table**: Faster ancestor/descendant queries but write amplification on every edge insert
   - Rejected: Phase 1 can tolerate slower traversal; optimize if hot path proven
2. **Materialized Path (ltree)**: Great for trees, awkward for general DAGs
   - Rejected: Dependency graphs are not tree-like (multiple parents common)

**References**:
- Postgres recursive CTEs: https://www.postgresql.org/docs/current/queries-with.html
- Bun CTE support: https://bun.uptrace.dev/guide/query-common-table-expressions.html

---

### 2. Go Graph Libraries for In-Memory Validation and Toposort

#### Decision: gonum.org/v1/gonum/graph

**Usage Pattern**:
```go
import (
  "gonum.org/v1/gonum/graph"
  "gonum.org/v1/gonum/graph/simple"
  "gonum.org/v1/gonum/graph/topo"
)

// Validate cycle-free and compute toposort in application layer
func ValidateAndSort(edges []Edge) ([]string, error) {
  g := simple.NewDirectedGraph()

  // Build graph from edges
  for _, e := range edges {
    g.SetEdge(simple.Edge{F: nodeID(e.FromState), T: nodeID(e.ToState)})
  }

  // Topological sort (fails if cycle)
  order, err := topo.Sort(g)
  if err != nil {
    // err is topo.Unorderable with Cycles field
    return nil, fmt.Errorf("cycle detected: %w", err)
  }

  // Convert node IDs back to state GUIDs
  return nodeIDsToGUIDs(order), nil
}
```

**Rationale**:
- **Pros**: Battle-tested, canonical Go graph library; native toposort + cycle detection
- **Cons**: Adds dependency (justified in Complexity Tracking)
- **Multigraph Support**: `graph/multi` package available if parallel edges needed as first-class
- **Integration**: Use in service layer pre-write; DB trigger is safety net
- **Bundle Impact**: Server-side only (gridapi), zero CLI/SDK bloat

**Alternatives Considered**:
1. **github.com/dominikbraun/graph**: Simpler API, but less mature (fewer stars/forks)
   - Rejected: Gonum is industry standard with better testing coverage
2. **Hand-rolled DFS toposort**: ~50 lines of code
   - Rejected: Error-prone for complex graphs; not worth maintenance burden

**References**:
- Gonum graph docs: https://pkg.go.dev/gonum.org/v1/gonum/graph
- Toposort package: https://pkg.go.dev/gonum.org/v1/gonum/graph/topo

---

### 3. Terraform State Parsing for Outputs

#### Decision: Custom JSON Parser with Canonical Fingerprinting

**Implementation**:
```go
// TFOutputs models minimal Terraform 1.x state structure for outputs
type TFOutputs struct {
  Outputs map[string]struct {
    Value interface{} `json:"value"`
  } `json:"outputs"`
}

// ParseOutputs extracts outputs from raw tfstate JSON
func ParseOutputs(tfstateJSON []byte) (map[string]interface{}, error) {
  var state TFOutputs
  if err := json.Unmarshal(tfstateJSON, &state); err != nil {
    return nil, err
  }

  outputs := make(map[string]interface{}, len(state.Outputs))
  for k, v := range state.Outputs {
    outputs[k] = v.Value
  }
  return outputs, nil
}

// ComputeFingerprint produces deterministic SHA-256 digest (base58 encoded)
func ComputeFingerprint(value interface{}) string {
  canonical := canonicalJSON(value)
  if canonical == nil {
    return ""
  }
  hash := sha256.Sum256(canonical)
  return base58.Encode(hash[:])
}

// canonicalJSON produces deterministic encoding for tfstate output values
func canonicalJSON(v interface{}) []byte {
  // Handle: nil, bool, float64, int, string, []interface{}, map[string]interface{}
  // Sort map keys lexicographically for determinism
  // See pseudocode from user research for full implementation
}
```

**Rationale**:
- **No Dependencies**: Use stdlib `encoding/json` + `crypto/sha256`
- **Determinism**: Canonical JSON encoding ensures same value → same fingerprint
- **Supported Types**: Covers Terraform output shapes (primitives, arrays, objects)
- **Fingerprint Storage**: Store in `edges.in_digest` (producer side) and `edges.out_digest` (consumer side)
- **Status Derivation**: `in_digest == out_digest` → clean; mismatch → dirty

**Edge Status Update Logic** (from user research):
```go
// UpdateEdges runs on every tfstate write (PUT to /tfstate/{guid})
func UpdateEdges(ctx context.Context, repo *EdgeRepository, stateGUID string, newTFState []byte) {
  outputs, _ := ParseOutputs(newTFState)

  // Update outgoing edges (this state is producer)
  for _, edge := range repo.GetOutgoingEdges(ctx, stateGUID) {
    if val, ok := outputs[edge.FromOutput]; ok {
      newDigest := ComputeFingerprint(val)
      if edge.InDigest != newDigest {
        edge.InDigest = newDigest
        edge.LastInAt = time.Now()
        // Recompute status vs out_digest
        edge.Status = deriveStatus(newDigest, edge.OutDigest)
        repo.Update(ctx, edge)
      }
    } else {
      edge.Status = "missing-output"
      repo.Update(ctx, edge)
    }
  }

  // Update incoming edges (this state is consumer, acknowledge observations)
  for _, edge := range repo.GetIncomingEdges(ctx, stateGUID) {
    if edge.InDigest != "" && edge.OutDigest != edge.InDigest {
      edge.OutDigest = edge.InDigest
      edge.LastOutAt = time.Now()
      edge.Status = "ok"
      repo.Update(ctx, edge)
    }
  }
}
```

**References**:
- Terraform state JSON schema: https://developer.hashicorp.com/terraform/language/state
- Attribution for edge update logic: https://github.com/diggerhq/digger (OpenTaco project)

---

### 4. State Status Computation (On-Demand Derivation)

#### Decision: Compute State Status from Edges, Never Persist

**Algorithm** (from user research):
```go
// ComputeStateStatus derives state status from all incoming edges + transitive propagation
func ComputeStateStatus(ctx context.Context, repo *EdgeRepository, stateGUID string) (*StateStatus, error) {
  allEdges := repo.GetAllEdges(ctx)

  // Build adjacency map
  adj := make(map[string][]string)
  incoming := []IncomingEdge{}
  for _, edge := range allEdges {
    adj[edge.FromState] = append(adj[edge.FromState], edge.ToState)
    if edge.ToState == stateGUID {
      incoming = append(incoming, IncomingEdge{
        FromState: edge.FromState,
        FromOutput: edge.FromOutput,
        Status: edge.Status,
        InDigest: edge.InDigest,
        OutDigest: edge.OutDigest,
      })
    }
  }

  // Determine red states: any state with incoming dirty edge
  red := make(map[string]bool)
  for _, e := range allEdges {
    if e.Status == "dirty" || e.Status == "pending" {
      red[e.ToState] = true
    }
  }

  // Propagate yellow from red upstreams (BFS)
  yellow := make(map[string]bool)
  queue := []string{}
  seen := make(map[string]bool)
  for s := range red {
    queue = append(queue, s)
    seen[s] = true
  }
  for len(queue) > 0 {
    cur := queue[0]
    queue = queue[1:]
    for _, next := range adj[cur] {
      if seen[next] { continue }
      yellow[next] = true
      seen[next] = true
      queue = append(queue, next)
    }
  }

  // Compute target state status
  status := "clean"
  if red[stateGUID] {
    status = "stale"  // Direct incoming dirty
  } else if yellow[stateGUID] {
    status = "potentially-stale"  // Transitive upstream dirty
  }

  return &StateStatus{
    StateGUID: stateGUID,
    Status: status,
    Incoming: incoming,
  }, nil
}
```

**Rationale**:
- **No Persistence**: State status is derived function, not stored column (avoids stale data)
- **Performance**: Phase 1 computes full graph in memory; acceptable for <5000 edges
- **Correctness**: Single source of truth (edges table); status always reflects current reality
- **Future Optimization**: If hot path, cache in-memory with TTL or event-driven invalidation

---

### 5. to_input_name Default Value Strategy

#### Decision: Application Layer Generation (Service Layer)

**Implementation**:
```go
// In dependency/service.go
func (s *DependencyService) AddDependency(ctx context.Context, req *AddDependencyRequest) (*Edge, error) {
  // Resolve from/to states
  fromState, _ := s.stateRepo.GetByLogicIDOrGUID(ctx, req.FromState)
  toState, _ := s.stateRepo.GetByLogicIDOrGUID(ctx, req.ToState)

  // Generate default to_input_name if not provided
  toInputName := req.ToInputName
  if toInputName == "" {
    // Default: slugify(from_logic_id) + "_" + slugify(from_output)
    toInputName = slugify(fromState.LogicID) + "_" + slugify(req.FromOutput)
  }

  edge := &models.Edge{
    FromState:   fromState.GUID,
    FromOutput:  req.FromOutput,
    ToState:     toState.GUID,
    ToInputName: toInputName,  // Always non-null when stored
    Status:      EdgeStatusPending,
  }

  return s.edgeRepo.Create(ctx, edge)
}
```

**Rationale**:
1. ✅ **Consistency**: Generated HCL blocks remain stable until user explicitly overrides
2. ✅ **User expectations**: CLI shows field as optional, users understand default behavior
3. ⚠️ **Logic-id changes**: If provider `logic_id` changes, `to_input_name` becomes stale
   - GUID-based lookup in consumer states remains valid (no breakage)
   - Future enhancement: detect logic_id changes and prompt user to update `to_input_name`
4. ✅ **Database normalization**: Store computed value (NOT NULL), enables uniqueness constraint

**Alternatives Rejected**:
1. ❌ **Database DEFAULT constraint**: Loses flexibility, hard to change logic without migration
2. ❌ **CLI generation time**: Stored NULL in DB would complicate uniqueness constraint handling

---

### 6. UpdateEdges Background Job Design

#### Decision: Internal Wiring in Handler (NOT Exposed Hook)

**Implementation**:
```go
// In tfstate_handlers.go:UpdateState
func (h *TerraformHandlers) UpdateState(w http.ResponseWriter, r *http.Request) {
  summary, err := h.service.UpdateStateContent(ctx, guid, body, lockID)
  if err != nil { /* handle */ }

  // Internal: trigger UpdateEdges asynchronously
  if h.edgeUpdater != nil {
    go h.edgeUpdater.UpdateEdges(context.Background(), guid, body)
  }

  w.WriteHeader(http.StatusOK)
}

// EdgeUpdateJob with per-state locking
type EdgeUpdateJob struct {
  edgeRepo  repository.EdgeRepository
  stateRepo repository.StateRepository
  parser    *tfstate.Parser
  locks     sync.Map  // map[string]*sync.Mutex keyed by stateGUID
}

func (j *EdgeUpdateJob) UpdateEdges(ctx context.Context, stateGUID string, tfstateJSON []byte) {
  // Per-state lock for concurrent safety
  lockVal, _ := j.locks.LoadOrStore(stateGUID, &sync.Mutex{})
  mu := lockVal.(*sync.Mutex)
  mu.Lock()
  defer mu.Unlock()

  // Best effort: parse outputs, update edges, log errors (no propagation)
  // ... (see data-model.md for full implementation)
}
```

**Rationale**:
1. ✅ **YAGNI**: Only one caller (Terraform PUT handler) exists or planned
2. ✅ **Simplicity**: No hook registration API, no interface complexity
3. ✅ **Best effort**: Fire-and-forget goroutine, no error handling in client path
4. ✅ **Concurrent safety**: Per-state mutex prevents race conditions
5. ✅ **Testability**: Integration tests verify end-to-end without mocking hooks

**Alternatives Rejected**:
1. ❌ **Hook pattern**: Adds unnecessary abstraction (hook registration, interfaces)
2. ❌ **Event bus**: Over-engineering for single caller scenario
3. ❌ **Service layer hook**: Leaks implementation detail into state service

**Trigger Point**: Automatically invoked after successful `UpdateStateContent` in `POST /tfstate/{guid}` handler

---

### 7. Managed HCL Generation (grid_dependencies.tf)

#### Decision: Template-Based Generation with Managed Block Markers

**Template Pattern** (using embed.FS like existing `backend.tf`):
```hcl
# BEGIN GRID MANAGED BLOCK - DO NOT EDIT
# Generated by Grid at {{.Timestamp}}
# Dependencies for state: {{.ConsumerLogicID}}

{{range .ProducerStates}}
data "terraform_remote_state" "{{.Slug}}" {
  backend = "http"
  config = {
    address        = "{{$.GridBaseURL}}/tfstate/{{.GUID}}"
    lock_address   = "{{$.GridBaseURL}}/tfstate/{{.GUID}}/lock"
    unlock_address = "{{$.GridBaseURL}}/tfstate/{{.GUID}}/unlock"
  }
}
{{end}}

locals {
{{range .Edges}}
  {{.ToInputName}} = data.terraform_remote_state.{{.ProducerSlug}}.outputs.{{.FromOutput}}
{{end}}
}

# END GRID MANAGED BLOCK
```

**Generation Logic**:
```go
// SyncDependencies generates grid_dependencies.tf in consumer state directory
func SyncDependencies(ctx context.Context, sdk *GridSDK, consumerLogicID string, targetDir string) error {
  // Fetch dependencies via RPC
  deps, err := sdk.ListDependencies(ctx, consumerLogicID)

  // Build template data
  data := TemplateData{
    ConsumerLogicID: consumerLogicID,
    Timestamp: time.Now().Format(time.RFC3339),
    GridBaseURL: sdk.BaseURL,
    ProducerStates: deduplicateProducers(deps),
    Edges: buildEdgeData(deps),
  }

  // Render template
  var buf bytes.Buffer
  tmpl.Execute(&buf, data)

  // Write to grid_dependencies.tf (idempotent overwrite)
  path := filepath.Join(targetDir, "grid_dependencies.tf")
  return os.WriteFile(path, buf.Bytes(), 0644)
}
```

**Rationale**:
- **Idempotency**: Overwrite entire file between markers; manual edits are reverted
- **Clarity**: HCL comments clearly mark managed section
- **Naming**: Default `<state_slug>_<output_slug>`; override with `to_input_name`
- **Deduplication**: Single `terraform_remote_state` per producer GUID
- **Validation**: Skip edges with `status == "missing-output"` in locals block

---

## Summary of Technology Choices

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| **Database Schema** | PostgreSQL edge table + cycle trigger | Simple, flexible, enforces DAG invariant at DB boundary |
| **Graph Algorithms** | gonum.org/v1/gonum/graph | Battle-tested toposort + cycle detection, standard in Go ecosystem |
| **tfstate Parsing** | Custom JSON parser (stdlib) | Zero dependencies, deterministic fingerprinting for observation tracking |
| **Edge Status Updates** | Background job on tfstate write (internal wiring) | Automatic reconciliation, decoupled from critical path, best-effort goroutine |
| **State Status** | On-demand computation (not persisted) | Single source of truth, avoids stale data |
| **to_input_name Default** | Application layer (service) generation | Consistency, user expectations, enables uniqueness constraint |
| **UpdateEdges Job** | Internal wiring in handler (NOT hook) | YAGNI, simplicity, per-state mutex for concurrent safety |
| **HCL Generation** | embed.FS template + managed markers | Idempotent, clear ownership, follows existing CLI pattern |
| **RPC Contract** | Connect RPC (extend StateService) | Contract-centric per constitution, cross-language parity |

---

## Open Questions Resolved

1. ✅ **Cycle prevention strategy**: DB trigger + application-layer Gonum validation (defense in depth)
2. ✅ **Edge status persistence**: Persist in `edges` table; compute state status on demand
3. ✅ **Mock value handling**: Store in `edges.mock_value` JSONB; transition independently per edge
4. ✅ **Fingerprint algorithm**: SHA-256 over canonical JSON, base58 encoded
5. ✅ **HCL managed block format**: Header/footer comments, idempotent overwrite
6. ✅ **to_input_name default generation**: Application layer (service) - compute default if not provided, store as NOT NULL
7. ✅ **to_input_name uniqueness**: Composite unique constraint `(to_state, to_input_name)` (always non-null)
8. ✅ **UpdateEdges background job**: Internal wiring in handler, NOT exposed as hook (per-state mutex, best-effort)

---

**Next Phase**: Proceed to Phase 1 (Design & Contracts) to generate data-model.md, protobuf contracts, and quickstart.md.
