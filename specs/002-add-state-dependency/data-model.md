# Data Model: State Dependency Management

**Feature**: State Dependency Management
**Date**: 2025-10-02
**Status**: Design Complete

## Entity Relationship Overview

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│   State     │         │     Edge     │         │   State     │
│  (Producer) │────────▶│ (Dependency) │────────▶│ (Consumer)  │
└─────────────┘  1:N    └──────────────┘   N:1   └─────────────┘
     │                         │
     │                         │
     ├─ outputs ───────────────┤
     │  (parsed from           │
     │   tfstate)              ├─ status
     │                         ├─ in_digest (producer output fingerprint)
     │                         ├─ out_digest (consumer observed fingerprint)
     │                         ├─ mock_value (optional, for ahead-of-time deps)
     │                         └─ to_input_name (optional, HCL local var override)
     │
     └─ state_content (bytea, contains tfstate JSON)
```

**Graph Constraints**:
- Directed Acyclic Multigraph (DAmG)
- Multiple edges between same state pair allowed (one per output key)
- No cycles permitted (enforced at DB + application layer)

---

## Core Entities

### 1. State (Existing)

**Location**: `cmd/gridapi/internal/db/models/state.go`

**Schema** (no changes to existing fields):
```go
type State struct {
  GUID         string    `bun:"guid,pk,type:uuid"`
  LogicID      string    `bun:"logic_id,notnull,unique"`
  StateContent []byte    `bun:"state_content,type:bytea"`  // Contains tfstate JSON
  Locked       bool      `bun:"locked,notnull,default:false"`
  LockInfo     *LockInfo `bun:"lock_info,type:jsonb"`
  CreatedAt    time.Time `bun:"created_at,notnull,default:current_timestamp"`
  UpdatedAt    time.Time `bun:"updated_at,notnull,default:current_timestamp"`
}
```

**Role in Dependencies**:
- Producer: Provides outputs parsed from `StateContent` (tfstate JSON)
- Consumer: Receives upstream outputs via dependency edges
- Outputs discovered via `ParseOutputs(StateContent)` helper

---

### 2. Edge (NEW)

**Location**: `cmd/gridapi/internal/db/models/edge.go`

**Schema**:
```go
type Edge struct {
  bun.BaseModel `bun:"table:edges,alias:e"`

  ID           int64      `bun:"id,pk,autoincrement"`
  FromState    string     `bun:"from_state,notnull,type:uuid"`
  FromOutput   string     `bun:"from_output,notnull"`
  ToState      string     `bun:"to_state,notnull,type:uuid"`
  ToInputName  string     `bun:"to_input_name,notnull"`  // Always non-null (generated by service if not provided)
  Status       EdgeStatus `bun:"status,notnull,default:'pending'"`
  InDigest     string     `bun:"in_digest"`      // Producer output fingerprint
  OutDigest    string     `bun:"out_digest"`     // Consumer observed fingerprint
  MockValue    []byte     `bun:"mock_value,type:jsonb"`  // Optional mock for ahead-of-time deps
  LastInAt     *time.Time `bun:"last_in_at"`
  LastOutAt    *time.Time `bun:"last_out_at"`
  CreatedAt    time.Time  `bun:"created_at,notnull,default:current_timestamp"`
  UpdatedAt    time.Time  `bun:"updated_at,notnull,default:current_timestamp"`
}

type EdgeStatus string

const (
  EdgeStatusPending         EdgeStatus = "pending"          // Initial state, no observation yet
  EdgeStatusClean           EdgeStatus = "clean"            // in_digest == out_digest
  EdgeStatusDirty           EdgeStatus = "dirty"            // in_digest != out_digest
  EdgeStatusPotentiallyStale EdgeStatus = "potentially-stale" // Transitive upstream dirty
  EdgeStatusMock            EdgeStatus = "mock"             // Using mock value, real output not yet exists
  EdgeStatusMissingOutput   EdgeStatus = "missing-output"   // Producer output key removed
)
```

**Constraints** (enforced in migration):
```sql
-- Composite unique constraint (multigraph: one edge per from_state + from_output + to_state combo)
UNIQUE (from_state, from_output, to_state)

-- to_input_name uniqueness per consumer state (always NOT NULL, generated by service layer)
UNIQUE (to_state, to_input_name)

-- Foreign keys with cascade delete
FOREIGN KEY (from_state) REFERENCES states(guid) ON DELETE CASCADE
FOREIGN KEY (to_state) REFERENCES states(guid) ON DELETE CASCADE
```

**Indexes**:
```sql
CREATE INDEX idx_edges_from_state ON edges(from_state);
CREATE INDEX idx_edges_to_state ON edges(to_state);
CREATE INDEX idx_edges_status ON edges(status);
```

**Validation Rules**:
```go
func (e *Edge) ValidateForCreate() error {
  // UUIDs
  if _, err := uuid.Parse(e.FromState); err != nil {
    return errors.New("from_state must be valid UUID")
  }
  if _, err := uuid.Parse(e.ToState); err != nil {
    return errors.New("to_state must be valid UUID")
  }

  // No self-loops
  if e.FromState == e.ToState {
    return errors.New("self-loops not allowed")
  }

  // from_output required
  if e.FromOutput == "" {
    return errors.New("from_output is required")
  }

  // to_input_name validation (always non-null after service layer processing)
  if e.ToInputName == "" {
    return errors.New("to_input_name is required (should be set by service layer)")
  }
  if !isValidSlug(e.ToInputName) {
    return errors.New("to_input_name must be valid slug: lowercase [a-z0-9_-]")
  }

  // Mock value only valid with mock status
  if e.MockValue != nil && e.Status != EdgeStatusMock {
    return errors.New("mock_value only allowed with status=mock")
  }

  return nil
}

func isValidSlug(s string) bool {
  return regexp.MustCompile(`^[a-z0-9_-]+$`).MatchString(s)
}
```

**to_input_name Default Generation** (Service Layer):

The `to_input_name` field is **optional in the RPC request**, but **always stored as non-null** in the database. Default generation happens in the service layer during `AddDependency`:

```go
// In dependency/service.go
func (s *DependencyService) AddDependency(ctx context.Context, req *AddDependencyRequest) (*Edge, error) {
  // Resolve from/to states by logic_id or GUID
  fromState, _ := s.stateRepo.GetByLogicIDOrGUID(ctx, req.FromState)
  toState, _ := s.stateRepo.GetByLogicIDOrGUID(ctx, req.ToState)

  // Generate default to_input_name if not provided
  toInputName := req.ToInputName
  if toInputName == "" {
    // Default: slugify(from_logic_id) + "_" + slugify(from_output)
    toInputName = slugify(fromState.LogicID) + "_" + slugify(req.FromOutput)
  }

  edge := &models.Edge{
    FromState:   fromState.GUID,
    FromOutput:  req.FromOutput,
    ToState:     toState.GUID,
    ToInputName: toInputName,  // Always non-null when stored
    Status:      EdgeStatusPending,
  }

  // Validate and persist
  if err := edge.ValidateForCreate(); err != nil {
    return nil, err
  }
  return s.edgeRepo.Create(ctx, edge)
}

func slugify(s string) string {
  // Convert to lowercase, replace non-alphanumeric with underscore
  s = strings.ToLower(s)
  s = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(s, "_")
  s = strings.Trim(s, "_")
  return s
}
```

**Design Rationale**:
1. ✅ **Consistency**: Generated HCL blocks remain stable until user explicitly overrides
2. ✅ **User expectations**: CLI shows field as optional, users understand default behavior
3. ⚠️ **Logic-id changes**: If provider `logic_id` changes, `to_input_name` becomes stale (but GUID-based lookup remains valid)
   - **Mitigation**: Future enhancement can detect logic_id changes and prompt user to update `to_input_name`
4. ✅ **Database normalization**: Store computed value (not NULL), enables uniqueness constraint enforcement

**State Transitions**:
```
pending ──────────────▶ clean          (consumer observes matching producer output)
        │
        └──────────────▶ dirty          (producer output changes after consumer observed)
        │
        └──────────────▶ missing-output (producer output key removed)

mock ──────────────────▶ pending        (producer output appears, transition to normal lifecycle)
                       │
                       └──────────────▶ clean (if consumer already observed real value)

clean ─────────────────▶ dirty          (producer output changes)

dirty ─────────────────▶ clean          (consumer re-observes updated output)

potentially-stale       (computed status, not persisted in edge; derived from transitive graph)
```

---

### 3. StateStatus (Derived Entity, NOT Persisted)

**Location**: Computed on-demand in `cmd/gridapi/internal/graph/status.go`

**Structure**:
```go
type StateStatus struct {
  StateGUID string            `json:"state_guid"`
  LogicID   string            `json:"logic_id"`
  Status    ComputedStatus    `json:"status"`
  Incoming  []IncomingEdgeView `json:"incoming"`
  Summary   StatusSummary     `json:"summary"`
}

type ComputedStatus string

const (
  StateClean            ComputedStatus = "clean"             // All incoming edges clean
  StateStale            ComputedStatus = "stale"             // At least one incoming edge dirty/pending
  StatePotentiallyStale ComputedStatus = "potentially-stale" // Transitive upstream dirty, direct edges clean
)

type IncomingEdgeView struct {
  EdgeID       int64      `json:"edge_id"`
  FromState    string     `json:"from_state"`
  FromLogicID  string     `json:"from_logic_id"`
  FromOutput   string     `json:"from_output"`
  Status       EdgeStatus `json:"status"`
  InDigest     string     `json:"in_digest,omitempty"`
  OutDigest    string     `json:"out_digest,omitempty"`
  LastInAt     *time.Time `json:"last_in_at,omitempty"`
  LastOutAt    *time.Time `json:"last_out_at,omitempty"`
}

type StatusSummary struct {
  IncomingClean   int `json:"incoming_clean"`
  IncomingDirty   int `json:"incoming_dirty"`
  IncomingPending int `json:"incoming_pending"`
  IncomingUnknown int `json:"incoming_unknown"`
}
```

**Derivation Algorithm** (see `research.md` for implementation):
1. Fetch all edges for state
2. Mark state as `stale` if ANY incoming edge is `dirty` or `pending`
3. Propagate `potentially-stale` to transitive downstream consumers via BFS
4. Otherwise, state is `clean`

---

### 4. ObservationRecord (Implicit, Derived from Edge Fields)

**Concept**: Not a separate table; observation tracking embedded in Edge model

**Fields**:
- `out_digest`: Fingerprint consumer observed from producer output
- `last_out_at`: Timestamp when consumer state was written (observation moment)

**Observation Definition** (from spec):
- Consumer state successfully written via Terraform HTTP Backend (PUT /tfstate/{guid})
- Consumer had access to producer outputs at write time (via managed locals block)
- `out_digest` set to `in_digest` value at observation time

---

### 5. UpdateEdges Background Job (Internal Wiring)

**Location**: `cmd/gridapi/internal/server/update_edges.go`

**Design Decision**: **NOT exposed as hook**, internally wired in Terraform HTTP Backend handler

**Implementation**:
```go
// TerraformHandlers has injected EdgeUpdateJob
type TerraformHandlers struct {
  service      StateService
  edgeUpdater  *EdgeUpdateJob  // Injected dependency
}

// In tfstate_handlers.go:UpdateState
func (h *TerraformHandlers) UpdateState(w http.ResponseWriter, r *http.Request) {
  // ... existing state update logic ...

  summary, err := h.service.UpdateStateContent(ctx, guid, body, lockID)
  if err != nil { /* handle */ }

  // Internal: trigger UpdateEdges asynchronously (best effort, no error handling)
  if h.edgeUpdater != nil {
    go h.edgeUpdater.UpdateEdges(context.Background(), guid, body)
  }

  w.WriteHeader(http.StatusOK)
}
```

**Background Job Structure**:
```go
// cmd/gridapi/internal/server/update_edges.go
type EdgeUpdateJob struct {
  edgeRepo  repository.EdgeRepository
  stateRepo repository.StateRepository
  parser    *tfstate.Parser
  locks     sync.Map  // map[string]*sync.Mutex keyed by stateGUID
}

func (j *EdgeUpdateJob) UpdateEdges(ctx context.Context, stateGUID string, tfstateJSON []byte) {
  // Acquire per-state lock (prevents concurrent updates to same state's edges)
  lockVal, _ := j.locks.LoadOrStore(stateGUID, &sync.Mutex{})
  mu := lockVal.(*sync.Mutex)
  mu.Lock()
  defer mu.Unlock()

  // Best effort: no error returns, log failures internally
  outputs, err := j.parser.ParseOutputs(tfstateJSON)
  if err != nil {
    log.Printf("failed to parse outputs for %s: %v", stateGUID, err)
    return
  }

  // Update outgoing edges (this state is producer)
  outgoing, _ := j.edgeRepo.GetOutgoingEdges(ctx, stateGUID)
  for _, edge := range outgoing {
    if val, ok := outputs[edge.FromOutput]; ok {
      newDigest := tfstate.ComputeFingerprint(val)
      if edge.InDigest != newDigest {
        edge.InDigest = newDigest
        edge.LastInAt = time.Now()
        edge.Status = deriveStatus(newDigest, edge.OutDigest)
        j.edgeRepo.Update(ctx, edge)
      }
    } else {
      edge.Status = EdgeStatusMissingOutput
      j.edgeRepo.Update(ctx, edge)
    }
  }

  // Update incoming edges (this state is consumer, acknowledge observations)
  incoming, _ := j.edgeRepo.GetIncomingEdges(ctx, stateGUID)
  for _, edge := range incoming {
    if edge.InDigest != "" && edge.OutDigest != edge.InDigest {
      edge.OutDigest = edge.InDigest
      edge.LastOutAt = time.Now()
      edge.Status = EdgeStatusClean
      j.edgeRepo.Update(ctx, edge)
    }
  }
}
```

**Design Rationale (Why NOT expose as hook)**:
1. ❌ **No abstraction needed**: Only one caller (Terraform PUT handler) exists or is planned
2. ❌ **Interface complexity**: Hook registration API adds unnecessary indirection
3. ❌ **Test simplicity**: Integration tests verify end-to-end behavior without mocking hooks
4. ✅ **Best effort semantics**: Fire-and-forget goroutine, no error propagation to client
5. ✅ **Concurrent safety**: Per-state mutex prevents race conditions on edge updates

**Trigger Point**: Automatically invoked after successful `UpdateStateContent` in Terraform HTTP Backend handler (`POST /tfstate/{guid}`)

---

### 6. TFOutput (Not Persisted, Parsed On-Demand)

**Location**: `cmd/gridapi/internal/tfstate/parser.go`

**Structure**:
```go
type TFOutputs struct {
  Outputs map[string]OutputValue `json:"outputs"`
}

type OutputValue struct {
  Value     interface{} `json:"value"`
  Sensitive bool        `json:"sensitive,omitempty"`
}

func ParseOutputs(tfstateJSON []byte) (map[string]interface{}, error) {
  var state TFOutputs
  if err := json.Unmarshal(tfstateJSON, &state); err != nil {
    return nil, err
  }

  outputs := make(map[string]interface{}, len(state.Outputs))
  for k, v := range state.Outputs {
    outputs[k] = v.Value
  }
  return outputs, nil
}
```

**Fingerprinting**:
```go
func ComputeFingerprint(value interface{}) string {
  canonical := canonicalJSON(value)  // Deterministic encoding
  hash := sha256.Sum256(canonical)
  return base58.Encode(hash[:])
}
```

---

## Repository Interface Extensions

### StateRepository (Existing, No Changes)

```go
type StateRepository interface {
  Create(ctx context.Context, state *models.State) error
  GetByGUID(ctx context.Context, guid string) (*models.State, error)
  GetByLogicID(ctx context.Context, logicID string) (*models.State, error)
  Update(ctx context.Context, state *models.State) error
  List(ctx context.Context) ([]models.State, error)
  Lock(ctx context.Context, guid string, lockInfo *models.LockInfo) error
  Unlock(ctx context.Context, guid string, lockID string) error
}
```

### EdgeRepository (NEW)

**Location**: `cmd/gridapi/internal/repository/bun_edge_repository.go`

```go
type EdgeRepository interface {
  // CRUD
  Create(ctx context.Context, edge *models.Edge) error
  GetByID(ctx context.Context, id int64) (*models.Edge, error)
  Delete(ctx context.Context, id int64) error
  Update(ctx context.Context, edge *models.Edge) error

  // Queries
  GetOutgoingEdges(ctx context.Context, fromStateGUID string) ([]models.Edge, error)
  GetIncomingEdges(ctx context.Context, toStateGUID string) ([]models.Edge, error)
  GetAllEdges(ctx context.Context) ([]models.Edge, error)
  FindByOutput(ctx context.Context, outputKey string) ([]models.Edge, error)

  // Cycle detection (uses DB trigger, but also pre-check in Go)
  WouldCreateCycle(ctx context.Context, fromState, toState string) (bool, error)
}
```

---

## Database Migration

**File**: `cmd/gridapi/internal/migrations/YYYYMMDDHHMMSS_add_edges_table.go`

**Migration Up**:
```go
func (m *AddEdgesTable) Up(ctx context.Context, db *bun.DB) error {
  // Create edges table
  _, err := db.NewCreateTable().
    Model((*models.Edge)(nil)).
    IfNotExists().
    Exec(ctx)
  if err != nil {
    return err
  }

  // Create indexes
  _, err = db.Exec("CREATE INDEX idx_edges_from_state ON edges(from_state)")
  _, err = db.Exec("CREATE INDEX idx_edges_to_state ON edges(to_state)")
  _, err = db.Exec("CREATE INDEX idx_edges_status ON edges(status)")

  // Create cycle prevention trigger
  _, err = db.Exec(`
    CREATE OR REPLACE FUNCTION prevent_cycle() RETURNS trigger AS $$
    BEGIN
      IF EXISTS (
        WITH RECURSIVE reachable(node) AS (
          SELECT NEW.to_state
          UNION ALL
          SELECT e.to_state FROM edges e JOIN reachable r ON e.from_state = r.node
        )
        SELECT 1 FROM reachable WHERE node = NEW.from_state
      ) THEN
        RAISE EXCEPTION 'cycle detected: % -> %', NEW.from_state, NEW.to_state;
      END IF;
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER edges_prevent_cycle
    BEFORE INSERT OR UPDATE ON edges
    FOR EACH ROW EXECUTE FUNCTION prevent_cycle();
  `)

  return err
}
```

**Migration Down**:
```go
func (m *AddEdgesTable) Down(ctx context.Context, db *bun.DB) error {
  _, err := db.Exec("DROP TRIGGER IF EXISTS edges_prevent_cycle ON edges")
  _, err = db.Exec("DROP FUNCTION IF EXISTS prevent_cycle()")
  _, err = db.NewDropTable().Model((*models.Edge)(nil)).IfExists().Exec(ctx)
  return err
}
```

---

## Cardinality & Scale Assumptions (Phase 1)

| Metric | Assumption | Rationale |
|--------|-----------|-----------|
| States | 1-1000 | Typical Terraform workspace count for medium org |
| Edges per state | 5-20 outgoing | Most states depend on 5-20 upstream outputs |
| Total edges | <5000 | Full graph fits in memory for toposort/BFS |
| Outputs per state | 10-50 | Typical Terraform module output count |
| Tfstate size | <10MB (warning threshold) | Existing State model constraint |

**Phase 2+ Optimizations** (deferred):
- Pagination for ListDependencies/ListDependents RPCs
- Incremental graph updates (vs full reload)
- Cached toposort results with event-driven invalidation

---

## Validation Summary

### Edge Creation Validation (FR-001 to FR-011)

1. ✅ Both `from_state` and `to_state` must exist in `states` table (FK constraint)
2. ✅ No self-loops: `from_state != to_state`
3. ✅ `from_output` is required (non-empty string)
4. ✅ Composite uniqueness: `(from_state, from_output, to_state)` must be unique
5. ✅ Optional `to_input_name` uniqueness: `(to_state, to_input_name)` where non-null
6. ✅ `to_input_name` must be valid slug: `[a-z0-9_-]`
7. ✅ Cycle prevention: DB trigger + application-layer Gonum check
8. ✅ Idempotent duplicate: Return existing edge, do not modify

### Edge Status Validation (FR-017 to FR-027)

1. ✅ Valid statuses: `pending`, `clean`, `dirty`, `potentially-stale`, `mock`, `missing-output`
2. ✅ `mock_value` only valid with `status=mock`
3. ✅ Timestamps in UTC (ISO 8601 format with timezone)
4. ✅ State status computed on-demand (not persisted)

---

**Next**: Proceed to protobuf contract definition (`contracts/dependency.proto`).
