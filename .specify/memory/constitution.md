# Grid Constitution

<!--
SYNC IMPACT REPORT - 2025-11-04

Version Change: 2.0.0 → 2.1.0

Modified Principles:
 - None

Added Sections:
 - IX. API Server Internal Layering (incorporated from cmd/gridapi/layering.md)

Removed Sections:
 - None

Templates requiring updates:
 - .specify/templates/plan-template.md (should reference layering discipline for API server changes)
 - .specify/templates/tasks-template.md (should enforce layer boundaries in implementation tasks)

Follow-up TODOs:
 - Audit existing API server code for layering violations (handlers importing repositories directly)
 - Refactor edge update job from internal/server to a service
 - Create IAM service to encapsulate auth workflows currently in handlers
-->

## Core Principles

### I. Go Workspace Architecture

**The project MUST use Go workspaces to manage multiple modules within a single repository.**

- Root `go.work` file declares all Go modules
- Each Go module maintains independent `go.mod`:
  - `api-server`: API server command
  - `pkg/sdk`: Public Go SDK package
  - `cli`: CLI client command
  - `api`: Autogenerated Connect RPC code (neutral module, no hand-written code)
- Node.js SDK lives under `js/sdk` with independent `package.json` + TypeScript configuration
- Module boundaries enforce architectural separation: API server, SDKs, and CLI are distinct compilation units
- Protobuf definitions live in `./proto/<service>/vX/<service>.proto` (not a Go module, source files only)
- Shared code (if any) lives in internal modules, not duplicated
- No `replace` directives in `go.mod` files for production dependencies

**Rationale**: Go workspaces provide native monorepo support, enabling independent versioning while maintaining a single source tree. This prevents version conflicts and simplifies local development without sacrificing module independence.

### II. Contract-Centric SDKs

**The Connect RPC contract is the single source of truth; SDKs wrap the contract while the API server owns business logic and persistence.**

- **Go SDK Package** (`pkg/sdk/`) and **Node.js SDK Package** (`js/sdk/`) expose ergonomic client APIs backed solely by generated Connect RPC clients in `./pkg/api`.
- SDKs MUST NOT contain server-side persistence, repository implementations, or domain mutations beyond request construction and response parsing.
- API server (`cmd/gridapi`) MUST implement business logic internally (e.g., `cmd/gridapi/internal/...`) and MUST NOT import `pkg/sdk` or `js/sdk`.
- Client applications (CLI, web, other services) MUST consume SDKs instead of calling Connect RPC clients directly when an SDK exists.

**Testing requirement**: Each SDK MUST provide contract tests against mocked or in-memory transports ensuring parity with the protobuf-defined contract before downstream consumers integrate.

**Rationale**: Centering the API contract keeps the server authoritative, prevents leakage of persistence concerns into client libraries, and still delivers consistent client ergonomics across languages.

### III. Dependency Flow Discipline

**The dependency graph MUST remain unidirectional: the API server depends on internal packages, SDKs depend on generated clients, and applications depend on SDKs.**

Allowed dependencies:
```
api-server    → cmd/gridapi/internal/... , api (generated clients)
cli           → pkg/sdk, api (Connect clients)
webapp        → js/sdk
pkg/sdk       → api (Connect clients)
js/sdk        → api (generated TypeScript/JavaScript)
api           ← (autogenerated, no dependencies on application code)
proto/        ← (definitions only, not a module)
```

**Prohibited**:
- API server importing client SDK modules (`pkg/sdk`, `js/sdk`)
- SDKs depending on applications (e.g., `pkg/sdk` importing `cli` code)
- Cross-application dependencies (e.g., `cli` importing `cmd/gridapi` internals)
- Circular references between modules
- Hand-written code in `./pkg/api` module (all code MUST be generated from `./proto`)

**Enforcement**: CI MUST audit dependency graphs (`go mod graph`, `pnpm ls --filter`) to confirm separation, fail builds if the API server pulls in SDK modules, and verify `./pkg/api` contains only generated code (checked via `buf lint` or custom script).

**Rationale**: Unidirectional dependencies keep the API authoritative, prevent client logic from leaking into server layers, and still ensure SDKs evolve from the shared protobuf contract.

### IV. Cross-Language Parity via Connect RPC

**API parity MUST be enforced using Connect RPC (https://connectrpc.com) with protobuf definitions.**

Architecture:
- **Protobuf definitions** at `./proto/<service>/vX/<service>.proto` are the single source of truth
- **Code generation** produces:
  - Go: Connect service handlers + clients in `./pkg/api` module
  - TypeScript/JavaScript: Connect clients for `js/sdk`
  - All other languages via standard protobuf + Connect plugins
- **Versioning**: Proto files organized by service and API version (`v1`, `v2`, etc.)
- **Generated code** in `./pkg/api` is committed to repository (no build-time generation required for consumers)

Rules:
- All RPC methods MUST be defined in `.proto` files first
- Hand-written SDKs wrap generated clients with idiomatic interfaces (e.g., error handling, retries)
- Breaking changes MUST increment proto version directory (e.g., `v1` → `v2`)
- Both Go and Node.js SDKs MUST implement wrappers for all proto services

**Validation**:
- CI verifies `./pkg/api` matches current proto definitions (`buf generate` idempotency check)
- Integration tests run against both SDKs to verify equivalent behavior

**Exceptions**: Language-specific SDK utilities (e.g., Go's `context.Context` helpers, Node.js streams) are allowed in SDK wrappers when they provide idiomatic value without breaking functional parity.

**Allowed Exceptions**:
- **Terraform HTTP Backend**: A single REST API endpoint at `/tfstate` on the API server implements the [Terraform HTTP Backend protocol](https://developer.hashicorp.com/terraform/language/settings/backends/http). This endpoint:
  - Is NOT reflected in protobuf definitions or SDKs
  - Exists solely for consumption by the standard Terraform/OpenTofu CLI binaries
  - Does NOT require SDK wrappers (external tool integration only)
  - MUST document its API contract in `docs/terraform-backend.md`
  - MUST have integration tests validating Terraform/OpenTofu CLI compatibility

- **OIDC Authentication Flow Helpers**: SDKs MAY provide helper functions for OIDC authentication flows (e.g., device code flow, browser-based login) that make direct HTTP calls to `/auth/*` endpoints instead of using Connect RPC. This exception applies to:
  - **Go SDK** (`pkg/sdk/auth.go`): `LoginWithDeviceCode`, `LoginWithServiceAccount` functions
  - **TypeScript SDK** (`js/sdk/auth.ts`): `initLogin`, `handleCallback`, `logout` functions
  - **Terraform wrapper** (`pkg/sdk/terraform/`): Process spawning, token injection, and credential management (not a Connect RPC concern)
  - **Justification**: OIDC protocol mandates specific HTTP redirect flows (authorization endpoint, callback URLs) that are incompatible with Connect RPC's request/response model. OAuth2 device authorization flow requires polling a token endpoint with specific error semantics (RFC 8628). These flows follow external protocol specifications (OIDC Core, OAuth2 RFC 6749) that cannot be mapped to protobuf/Connect RPC without losing protocol compliance.
  - **Constraints**: Auth helper functions MUST be well-documented as exceptions, clearly separated from RPC-backed SDK functions, and MUST NOT implement business logic beyond protocol flow orchestration. Administrative auth operations (role management, permission introspection) MUST remain in Connect RPC.

**Rationale**: Connect RPC combines protobuf's cross-language type safety with HTTP/2 and gRPC-Web compatibility. Autogeneration eliminates manual synchronization errors, ensures API parity by construction, and provides forward/backward compatibility guarantees through protobuf's versioning rules. This is far more reliable than manual SDK maintenance.

The Terraform backend exception is justified because it serves an external tool (Terraform) with a pre-defined protocol specification, not custom application logic requiring SDKs. The OIDC authentication exception is justified because standard authentication flows require specific HTTP redirect patterns and URL-based callbacks that cannot be expressed in Connect RPC while maintaining protocol compliance.

### V. Test Strategy

**Each module MUST have isolated tests; integration tests MUST validate cross-module interactions.**

Per-module testing:
- **pkg/sdk**: Go unit tests for all exported functions, table-driven where applicable
- **js/sdk**: Vitest tests with coverage >80%
- **api-server**: Contract tests for HTTP handlers, integration tests with real SDK
- **cli**: Command output tests, E2E tests with real SDK
- **webapp**: Component tests, integration tests with mocked Node.js SDK
- **proto/**: Schema validation via `buf lint`, breaking change detection via `buf breaking`

Cross-module testing:
- **Integration suite**: Tests running API server + CLI against the same workspace
- **Contract tests**: Validate API server responses match SDK expectations (derived from proto contracts)
- **Quickstart validation**: `quickstart.md` scenarios run as automated tests

**TDD requirement**: Contract and integration tests MUST be written first and MUST fail before implementation.

**Connect RPC Testing Patterns**:

For **Go clients** (follow [Connect RPC unit testing best practices](https://kmcd.dev/posts/connectrpc-unittests)):
- Use **table-driven tests** for multiple input scenarios (success, validation, errors)
- Test **direct service calls** without networking for unit isolation
- Use `net/http/httptest` for integration testing with full client-server interaction
- Test context cancellation and timeout handling
- Leverage Go's standard testing frameworks (testify for assertions)

For **web clients** (follow [official Connect RPC web testing guide](https://connectrpc.com/docs/web/testing)):
- Use `createRouterTransport()` from `@connectrpc/connect` for in-memory mock servers
- Inject `Transport` objects via framework-specific patterns:
  - React: Component props or Context API
  - Svelte: Context API
  - Vue: Provide/Inject API
- Prefer schema-based serialization over mocking `fetch` (tests full request flow)
- Use `@connectrpc/connect-playwright` for E2E testing with type-safe mocking

**Rationale**: Module-level tests ensure unit correctness; integration tests catch workspace-level misconfigurations. This layered approach scales with monorepo complexity. Protobuf schema validation catches API contract violations before code generation. Connect RPC's testing utilities provide type-safe mocking that validates against actual service definitions, preventing drift between tests and implementation.

### VI. Versioning & Releases

**Modules MUST version independently; releases MAY be coordinated for breaking changes.**

Version scheme (per module):
- **pkg/sdk**: Go module versioning (`v1.2.3` tags → `pkg/sdk/v1`)
- **js/sdk**: npm semantic versioning in `package.json`
- **api-server**: Calendar versioning or Docker tags (not a library)
- **cli**: Follows pkg/sdk version for major releases, independent for CLI-only features
- **api**: Follows protobuf versioning (`proto/<service>/v1` → `api/<service>/v1`)
- **proto/**: Version directories (`v1`, `v2`) never deleted, only added

Release coordination:
- **Backward-compatible SDK changes**: Independent releases
- **Breaking proto changes**: New version directory + coordinated SDK releases with migration guide
- **API server releases**: Include minimum SDK version and proto version requirements

**Allowed Exceptions**:
- **Unified CI/CD Versioning (Temporary)**: For the initial implementation of the CI/CD workflows (Feature `008-cicd-workflows`), a unified versioning scheme managed by a single `release-please` configuration at the repository root is permitted. All modules (gridapi, gridctl, pkg/sdk, js/sdk, webapp) will share a single version for releases.
  - **Justification**: This approach dramatically simplifies the initial CI/CD setup, aligning with Principle VII (Simplicity & Pragmatism) by avoiding premature complexity. The operational cost of managing independent versioning workflows has not yet been demonstrated.
  - **Constraint**: This exception is considered temporary. The decision will be revisited when the first evidence emerges that unified versioning is blocking legitimate independent release cadences for different modules. At that point, a migration to `release-please`'s monorepo mode with per-package manifests will be planned.

**Rationale**: Independent versioning allows rapid iteration on applications without SDK churn. Coordinated releases for breaking changes ensure ecosystem coherence. Protobuf's multi-version support enables gradual migration paths.

### VII. Simplicity & Pragmatism

**Start minimal; add complexity only when pain is demonstrated.**

YAGNI principles:
- **Don't** create shared internal modules until code is duplicated in 3+ places
- **Don't** add abstraction layers (e.g., repository pattern) until persistence layer changes
- **Don't** create workspace-wide tooling until manual process fails repeatably
- **Don't** add proto services until RPC need is proven (local function calls are simpler)
- **Do** use standard library over dependencies when feature parity exists
- **Do** choose boring technology (avoid bleeding-edge Go features, npm packages)
- **Do** use Connect RPC's built-in features before custom middleware

Complexity gates:
- New module requires RFC document explaining why existing modules insufficient
- New proto service requires justification (why not extend existing service?)
- New dependency requires justification (maintenance burden, supply chain risk, bundle size)

**Rationale**: Monorepos accumulate complexity faster than single projects. Defensive minimalism prevents premature abstraction and keeps the codebase navigable. Even with code generation, unnecessary RPC boundaries add latency and debugging complexity.

### VIII. Service Exposure Discipline

**All externally reachable services MUST traverse the shared authentication and authorization guards.**

- Connect RPC routers MUST only be mounted through the HTTP stack in `cmd/gridapi/cmd/serve.go`, downstream of the canonical `authn` and `authz` middleware chain. Alternate muxes or ad-hoc servers require an approved architecture change.
- Each RPC handler MUST enforce its own role and scope requirements (e.g., admin-only checks) in addition to the coarse HTTP guard. Omitting handler-level enforcement constitutes a bug.
- Any non-Chi transport (gRPC gateway, direct HTTP proxy, tests that invoke handlers directly) MUST register equivalent authentication and authorization interceptors before dispatching to service code. Bypassing those guards is prohibited unless explicitly documented and accepted in a design review.

**Rationale**: Prevents inadvertent exposure of privileged RPCs, ensures fine-grained authorization lives with the business logic, and keeps alternative transports from silently bypassing critical security middleware.

### IX. API Server Internal Layering

**The API server (`cmd/gridapi`) MUST enforce strict layering to separate transport, business logic, and persistence concerns.**

This principle applies exclusively to the API server module and defines internal architectural boundaries that complement workspace-level dependency rules.

**Layer Hierarchy** (strict unidirectional dependencies, top to bottom):

1. **Data Models** (`internal/db/models`)
   - Purpose: DB entities, value objects, constants. No business logic.
   - Allowed deps: Standard library only.

2. **DB Providers & Migrations** (`internal/db/bunx`, `internal/migrations`)
   - Purpose: DB connections, dialect specifics, schema migrations.
   - Allowed deps: Models, ORM libraries (Bun).
   - Not allowed: Domain logic, HTTP/Connect types.

3. **Repositories (Data Access Layer)** (`internal/repository`)
   - Purpose: CRUD operations, query composition, dialect abstraction.
   - Allowed deps: Models, DB providers.
   - Not allowed: HTTP/Connect handlers, server types, services, middleware.

4. **Services (Domain Logic)** (`internal/state`, `internal/dependency`, `internal/tfstate`, `internal/graph`)
   - Purpose: Business rules, validation, orchestration across repositories.
   - Allowed deps: Repositories (via interfaces), Models, other services, pure utilities.
   - Not allowed: HTTP/Connect transport specifics, handlers, middleware.

5. **Auth** (`internal/auth`)
   - Purpose: OIDC/JWT verification, claims parsing, Casbin policy enforcement.
   - Recommendation: Create `iam` service to encapsulate user/session/role workflows.
   - Allowed deps: Auth libraries, configuration, services (not repositories directly).

6. **Middleware** (`internal/middleware`)
   - Purpose: Request-scoped concerns (authn, authz, logging, metrics).
   - Resource attribute extraction MUST use Services, not Repositories.
   - Allowed deps: Auth (verifier/enforcer), Services, Config.
   - Not allowed: Direct repository access for business state.

7. **Server (Handlers)** (`internal/server`)
   - Purpose: HTTP/Connect transport layer, request validation, proto↔domain mapping.
   - Handlers MUST NOT import `internal/repository`. Use Services exclusively.
   - Allowed deps: Services, Auth (identity extraction), Middleware types (for wiring).

8. **Commands (CLI)** (`cmd/gridapi/cmd/*`)
   - Purpose: Dependency injection, wiring, server lifecycle.
   - Admin commands MUST use Services, not Repositories directly.
   - Allowed deps: Config, DB provider (wiring), Repositories (wiring), Services, Server router.

**Enforcement Rules**:

- **Handlers → Services**: HTTP/Connect handlers MUST call services for all business operations. Direct repository imports in handlers constitute a violation.
- **Middleware → Services**: Middleware extracting resource attributes (e.g., state ownership checks) MUST delegate to services, not query repositories.
- **CLI → Services**: Admin commands (e.g., `gridapi db seed`) MUST use services for domain operations, not implement business logic inline or access repositories directly.
- **Services are Façades**: Services encapsulate all business workflows: validation, multi-repository orchestration, domain invariant enforcement, auth/IAM flows.

**Known Violations (Technical Debt)**:

The following violations are documented for remediation:

- **Edge Update Job**: Lives in `internal/server` and updates repositories directly. Must be extracted to a service in `internal/dependency` (or new `edgeupdater` service) and injected into handlers via interface.
- **Auth Handlers**: Connect auth handlers and SSO HTTP handlers manipulate repositories and Casbin directly. Must introduce `iam` service and route all user/session/role operations through it.



**Rationale**: Clear layering prevents business logic leakage into transport code, enables safe refactoring (swap repository implementations), simplifies testing (mock service boundaries instead of DB interactions), and ensures handlers remain thin orchestration layers. This complements workspace-level dependency discipline (Principle III) by enforcing separation *within* the API server module.

## Development Workflow

**Code review requirements**:
- All PRs MUST pass CI (lint, test, build for all modules)
- Proto changes MUST pass `buf lint` and `buf breaking` checks
- Generated code in `./pkg/api` MUST be committed alongside proto changes
- Cross-language changes (affecting both SDKs) MUST include updated integration tests
- Breaking changes MUST update `CHANGELOG.md` and include migration notes
- API server code reviews MUST reject imports from client SDK modules; rely on internal packages instead

**Branch strategy**:
- Feature branches: `###-feature-name` (where ### is issue number)
- Release branches: `release/sdk-go/v1.2.0`, `release/sdk-nodejs/v1.3.0`
- Main branch (`main`) always buildable, protected

**CI enforcement**:
- Workspace-wide tests run on every PR
- Module-specific tests run when module files change
- Dependency graph analysis fails on circular dependencies or violations of Principle III
- Proto changes trigger regeneration check (`buf generate --dry-run` must match committed files)
- Builds MUST fail if the API server imports client SDK modules (enforced via dependency checks)
- Static analysis MUST detect API server layer violations (Principle IX)

**Protobuf workflow**:
1. Edit `.proto` files in `./proto/<service>/vX/`
2. Run `buf generate` to update `./pkg/api` module
3. Update SDK wrappers in `pkg/sdk` and `js/sdk` to expose new functionality (without re-implementing server persistence logic)
4. Commit proto files + generated code + SDK wrappers together

## Governance

**Constitution Authority**: This document supersedes informal practices. All architectural decisions, code reviews, and tooling choices MUST align with these principles.

**Amendment Process**:
1. Propose change via RFC document in `docs/rfcs/`
2. Demonstrate either (a) principle violation blocking critical work, or (b) principle improvement based on evidence
3. Require approval from 2+ maintainers
4. Update constitution version (see versioning rules below)
5. Create migration plan if existing code violates amended principles

**Version Semantics**:
- **MAJOR**: Backward-incompatible principle changes (e.g., redefining SDK responsibilities or removing contract-centric guarantees)
- **MINOR**: New principles added or existing principles expanded
- **PATCH**: Clarifications, examples, typo fixes

**Compliance Review**: Every release cycle (or quarterly), audit one randomly-selected module for constitutional compliance. Document findings in `docs/compliance/YYYY-QQ.md`.

**Violation Handling**:
- Technical debt violating principles MUST be tracked in issues with `constitution-debt` label
- New code introducing violations MUST justify in PR description and add to Complexity Tracking
- Unapproved violations block PR merge

**Version**: 2.1.0 | **Ratified**: 2025-09-30 | **Last Amended**: 2025-11-04
